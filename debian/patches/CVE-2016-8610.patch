From 648bf9b00e1cbf45c6d05fab07e91fad97e6926d Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos <nmav@redhat.com>
Date: Fri, 14 Oct 2016 10:22:07 +0200
Subject: [PATCH] handshake: set a maximum number of warning messages that can be received per handshake

That is to avoid DoS due to the assymetry of cost of sending an alert vs the cost
of processing.
---
 lib/gnutls_handshake.c | 15 ++++++++++-----
 lib/gnutls_int.h       |  6 +++---
 lib/gnutls_state.c     |  2 +-
 3 files changed, 14 insertions(+), 9 deletions(-)

Index: gnutls28-3.4.10/lib/gnutls_handshake.c
===================================================================
--- gnutls28-3.4.10.orig/lib/gnutls_handshake.c	2017-01-26 10:10:32.256534850 -0500
+++ gnutls28-3.4.10/lib/gnutls_handshake.c	2017-01-26 10:10:32.248534735 -0500
@@ -2649,12 +2649,17 @@
 			return ret; \
 		if (ret == GNUTLS_E_GOT_APPLICATION_DATA && session->internals.initial_negotiation_completed != 0) \
 			return ret; \
-		if (ret == GNUTLS_E_LARGE_PACKET && session->internals.handshake_large_loops < 16) { \
-			session->internals.handshake_large_loops++; \
-			return ret; \
+		if (session->internals.handshake_suspicious_loops < 16) { \
+			if (ret == GNUTLS_E_LARGE_PACKET) { \
+				session->internals.handshake_suspicious_loops++; \
+				return ret; \
+			} \
+			/* a warning alert might interrupt handshake */ \
+			if (allow_alert != 0 && ret==GNUTLS_E_WARNING_ALERT_RECEIVED) { \
+				session->internals.handshake_suspicious_loops++; \
+				return ret; \
+			} \
 		} \
-                /* a warning alert might interrupt handshake */ \
-		if (allow_alert != 0 && ret==GNUTLS_E_WARNING_ALERT_RECEIVED) return ret; \
 		gnutls_assert(); \
 		ERR( str, ret); \
 		/* do not allow non-fatal errors at this point */ \
Index: gnutls28-3.4.10/lib/gnutls_int.h
===================================================================
--- gnutls28-3.4.10.orig/lib/gnutls_int.h	2017-01-26 10:10:32.256534850 -0500
+++ gnutls28-3.4.10/lib/gnutls_int.h	2017-01-26 10:10:32.252534793 -0500
@@ -953,9 +953,9 @@
 
 	/* DTLS session state */
 	dtls_st dtls;
-	/* In case of clients that don't handle GNUTLS_E_LARGE_PACKET, don't
-	 * force them into an infinite loop */
-	unsigned handshake_large_loops;
+	/* Protect from infinite loops due to GNUTLS_E_LARGE_PACKET non-handling
+	 * or due to multiple alerts being received. */
+	unsigned handshake_suspicious_loops;
 	/* should be non-zero when a handshake is in progress */
 	bool handshake_in_progress;
 
Index: gnutls28-3.4.10/lib/gnutls_state.c
===================================================================
--- gnutls28-3.4.10.orig/lib/gnutls_state.c	2017-01-26 10:10:32.256534850 -0500
+++ gnutls28-3.4.10/lib/gnutls_state.c	2017-01-26 10:10:32.252534793 -0500
@@ -262,7 +262,7 @@
 
 	session->internals.resumable = RESUME_TRUE;
 
-	session->internals.handshake_large_loops = 0;
+	session->internals.handshake_suspicious_loops = 0;
 	session->internals.dtls.hsk_read_seq = 0;
 	session->internals.dtls.hsk_write_seq = 0;
 }
